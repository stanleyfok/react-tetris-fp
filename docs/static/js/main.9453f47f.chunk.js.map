{"version":3,"sources":["Tetris/components/Pixel/Pixel.js","Tetris/components/Grid/Grid.js","Tetris/types/Shape.js","Tetris/types/Grid.js","Tetris/types/GameState.js","Tetris/Tetris.js","App.js","serviceWorker.js","index.js","tetris-bg.mp3"],"names":["Pixel","props","classNames","isFilled","push","className","join","defaultProps","Grid","gridContent","grid","map","row","i","rowContent","col","j","key","SHAPE_TYPES","SQUARE","T","S","Z","BAR","L","FLIP_L","getRandomShape","totalShapes","Object","keys","length","type","size","orientations","position","rotation","getShapeByType","Math","floor","random","getShapeOrientation","shape","moveShape","vector","createGrid","rows","cols","getEmptyMap","Array","fill","addShapeToGrid","orientation","checkX","checkY","clearFullRows","flow","clearFullRowsFromGridMap","curry","padRowsToGridMap","filter","reduce","acc","value","ACTION","MOVE_DOWN","MOVE_LEFT","MOVE_RIGHT","ROTATE","createGameState","getNextShape","unclearedGrid","displayGrid","isGameOver","getNextGameState","action","gameState","rotateShape","hasCollisionInRow","hasCollisionInPixel","actualX","actualY","hasCollision","cloneDeep","Tetris","handleKeyDown","e","keyCode","moveShapeLeft","moveShapeRight","moveShapeDown","startNewGame","tickInterval","setState","timer","setTimeout","doGameTick","alert","state","document","addEventListener","this","removeEventListener","React","Component","App","normalInterval","src","tetrisBg","autoPlay","loop","Boolean","window","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister","module","exports"],"mappings":"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","file":"static/js/main.9453f47f.chunk.js","sourcesContent":["import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport \"./Pixel.css\";\n\n// pure component 🌟\nfunction Pixel(props) {\n  const { isFilled } = props;\n\n  const classNames = [\"pixel\"];\n  if (isFilled) {\n    classNames.push(\"pixel--filled\");\n  }\n\n  return <div className={classNames.join(\" \")}></div>;\n}\n\nPixel.propTypes = {\n  isFilled: PropTypes.bool\n};\n\nPixel.defaultProps = {\n  isFilled: false\n};\n\nexport default Pixel;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport Pixel from \"../Pixel/Pixel\";\n\nimport \"./Grid.css\";\n\n// pure component 🌟\nfunction Grid(props) {\n  const { map } = props.grid;\n\n  const gridContent = map.map((row, i) => {\n    const rowContent = row.map((col, j) => {\n      return <Pixel key={`pixel-${i},${j}`} isFilled={col} />;\n    });\n\n    return <div key={`row-${i}`}>{rowContent}</div>;\n  });\n\n  return <div className=\"grid\">{gridContent}</div>;\n}\n\nGrid.propTypes = {\n  grid: PropTypes.object.isRequired\n};\n\nexport default Grid;\n","const SHAPE_TYPES = {\n  SQUARE: 0,\n  T: 1,\n  S: 2,\n  Z: 3,\n  BAR: 4,\n  L: 5,\n  FLIP_L: 6\n};\n\n// 🌟: pure function\nexport const createBarShape = () => {\n  return {\n    size: 4,\n    orientations: [\n      [\n        [0, 1, 0, 0],\n        [0, 1, 0, 0],\n        [0, 1, 0, 0],\n        [0, 1, 0, 0]\n      ],\n      [\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 0, 0, 0],\n        [0, 0, 0, 0]\n      ]\n    ],\n    position: [0, 0],\n    rotation: 0\n  };\n};\n\n// 🌟: pure function\nexport const createFlipLShape = () => {\n  return {\n    size: 3,\n    orientations: [\n      [\n        [0, 0, 1],\n        [0, 0, 1],\n        [0, 1, 1]\n      ],\n      [\n        [1, 0, 0],\n        [1, 1, 1],\n        [0, 0, 0]\n      ],\n      [\n        [1, 1, 0],\n        [1, 0, 0],\n        [1, 0, 0]\n      ],\n      [\n        [1, 1, 1],\n        [0, 0, 1],\n        [0, 0, 0]\n      ]\n    ],\n    position: [0, 0],\n    rotation: 0\n  };\n};\n\n// 🌟: pure function\nexport const createLShape = () => {\n  return {\n    size: 3,\n    orientations: [\n      [\n        [1, 0, 0],\n        [1, 0, 0],\n        [1, 1, 0]\n      ],\n      [\n        [0, 0, 1],\n        [1, 1, 1],\n        [0, 0, 0]\n      ],\n      [\n        [0, 1, 1],\n        [0, 0, 1],\n        [0, 0, 1]\n      ],\n      [\n        [1, 1, 1],\n        [1, 0, 0],\n        [0, 0, 0]\n      ]\n    ],\n    position: [0, 0],\n    rotation: 0\n  };\n};\n\n// 🌟: pure function\nexport const createSquareShape = () => {\n  return {\n    size: 2,\n    orientations: [\n      [\n        [1, 1],\n        [1, 1]\n      ]\n    ],\n    position: [0, 0],\n    rotation: 0\n  };\n};\n\n// 🌟: pure function\nexport const createSShape = () => {\n  return {\n    size: 3,\n    orientations: [\n      [\n        [0, 1, 1],\n        [1, 1, 0],\n        [0, 0, 0]\n      ],\n      [\n        [0, 1, 0],\n        [0, 1, 1],\n        [0, 0, 1]\n      ]\n    ],\n    position: [0, 0],\n    rotation: 0\n  };\n};\n\n// 🌟: pure function\nexport const createTShape = () => {\n  return {\n    size: 3,\n    orientations: [\n      [\n        [0, 1, 0],\n        [1, 1, 1],\n        [0, 0, 0]\n      ],\n      [\n        [0, 1, 0],\n        [0, 1, 1],\n        [0, 1, 0]\n      ],\n      [\n        [0, 0, 0],\n        [1, 1, 1],\n        [0, 1, 0]\n      ],\n      [\n        [0, 1, 0],\n        [1, 1, 0],\n        [0, 1, 0]\n      ]\n    ],\n    position: [0, 0],\n    rotation: 0\n  };\n};\n\n// 🌟: pure function\nexport const createZShape = () => {\n  return {\n    size: 3,\n    orientations: [\n      [\n        [1, 1, 0],\n        [0, 1, 1],\n        [0, 0, 0]\n      ],\n      [\n        [0, 0, 1],\n        [0, 1, 1],\n        [0, 1, 0]\n      ]\n    ],\n    position: [0, 0],\n    rotation: 0\n  };\n};\n\n// 🌟: pure function\nexport const getShapeByType = type => {\n  // TODO: I am not happy with switch statement\n  switch (type) {\n    case SHAPE_TYPES.SQUARE:\n      return createSquareShape();\n    case SHAPE_TYPES.T:\n      return createTShape();\n    case SHAPE_TYPES.S:\n      return createSShape();\n    case SHAPE_TYPES.Z:\n      return createZShape();\n    case SHAPE_TYPES.BAR:\n      return createBarShape();\n    case SHAPE_TYPES.L:\n      return createLShape();\n    case SHAPE_TYPES.FLIP_L:\n      return createFlipLShape();\n    default:\n      return createBarShape();\n  }\n};\n\n// impure function due to randomness\nexport const getRandomShape = () => {\n  const totalShapes = Object.keys(SHAPE_TYPES).length;\n  const type = Math.floor(Math.random() * totalShapes);\n\n  return getShapeByType(type);\n};\n\n// 🌟: pure function\nexport const getShapeOrientation = shape => {\n  return shape.orientations[shape.rotation];\n};\n\n// 🌟: pure function\nexport const moveShape = (shape, vector) => {\n  return {\n    ...shape,\n    position: [shape.position[0] + vector[0], shape.position[1] + vector[1]]\n  };\n};\n\n// 🌟: pure function\nexport const rotateShape = shape => {\n  return {\n    ...shape,\n    rotation: (shape.rotation + 1) % shape.orientations.length\n  };\n};\n","import { flow, curry } from \"lodash/fp\";\nimport { getShapeOrientation } from \"./Shape\";\n\n// 🌟: pure function\nexport const createGrid = (rows, cols) => {\n  return {\n    map: getEmptyMap(rows, cols),\n    rows,\n    cols\n  };\n};\n\n// 🌟: pure function\nconst getEmptyMap = (rows, cols) => {\n  // 👍: create a 2d array with init value in 1 line\n  return Array(rows).fill(new Array(cols).fill(false));\n};\n\n// 🌟: pure function\nexport const hasCollision = (shape, grid) => {\n  const orientation = getShapeOrientation(shape);\n\n  // 👍: using nested reduce to check collision\n  return orientation.reduce(\n    (hasCollisionInRow, row, i) =>\n      row.reduce((hasCollisionInPixel, col, j) => {\n        if (col === 1) {\n          const actualX = shape.position[0] + j;\n          const actualY = shape.position[1] + i;\n\n          // ignore if still above the top\n          if (actualY < 0) {\n            return hasCollisionInPixel;\n          }\n\n          // check if hitting the bottom wall\n          if (actualY >= grid.rows) {\n            return true;\n          }\n\n          // check if hitting the left and right walls\n          if (actualX < 0 || actualX >= grid.cols) {\n            return true;\n          }\n\n          // check if hitting an unclear pixel\n          if (grid.map[actualY][actualX] === true) {\n            return true;\n          }\n        }\n\n        return hasCollisionInPixel;\n      }, hasCollisionInRow),\n    false\n  );\n};\n\n// 🌟: pure function\nexport const addShapeToGrid = (shape, grid) => {\n  const orientation = getShapeOrientation(shape);\n\n  return {\n    ...grid,\n    // 👍: using nested map to calculate a new map\n    map: grid.map.map((row, i) => {\n      return row.map((col, j) => {\n        const checkX = j - shape.position[0];\n        const checkY = i - shape.position[1];\n\n        if (\n          checkX >= 0 &&\n          checkX < shape.size &&\n          checkY >= 0 &&\n          checkY < shape.size &&\n          orientation[checkY][checkX] === 1\n        ) {\n          return true;\n        }\n\n        return col;\n      });\n    })\n  };\n};\n\n// 🌟: pure function\nexport const clearFullRows = grid => {\n  return {\n    ...grid,\n    // 👍: method composition\n    map: flow(\n      clearFullRowsFromGridMap,\n      curry(padRowsToGridMap)(grid.rows)(grid.cols)\n    )(grid.map)\n  };\n};\n\n// 🌟: pure function\nconst clearFullRowsFromGridMap = map => {\n  return map.filter(row => !row.reduce((acc, value) => (acc &= value), true));\n};\n\n// 🌟: pure function\nconst padRowsToGridMap = (rows, cols, map) => {\n  return [...getEmptyMap(rows - map.length, cols), ...map];\n};\n","import { flow, curry, cloneDeep } from \"lodash/fp\";\nimport { getRandomShape, moveShape, rotateShape } from \"./Shape\";\nimport {\n  createGrid,\n  hasCollision,\n  addShapeToGrid,\n  clearFullRows\n} from \"./Grid\";\n\nexport const ACTION = {\n  MOVE_DOWN: 0,\n  MOVE_LEFT: 1,\n  MOVE_RIGHT: 2,\n  ROTATE: 3\n};\n\n// 🌟: pure function\nexport const createGameState = (rows, cols) => {\n  return {\n    shape: getNextShape(cols),\n    unclearedGrid: createGrid(rows, cols),\n    displayGrid: createGrid(rows, cols),\n    isGameOver: false\n  };\n};\n\n// impure function due to randomness\n// since generating next shape is by random, it is not predictive\nconst getNextShape = cols => {\n  const shape = getRandomShape();\n\n  shape.rotation = Math.floor(Math.random() * shape.orientations.length);\n  shape.position = [\n    Math.floor((cols - shape.size) / 2), // middle of tower\n    -shape.size // top of tower\n  ];\n\n  return shape;\n};\n\n// 🌟: pure function\nexport const getNextGameState = (action, gameState) => {\n  // TODO: I am not happy with these let variables\n  let shape;\n  let unclearedGrid;\n  let isGameOver = false;\n\n  // TODO: I am not happy with switch statement\n  switch (action) {\n    case ACTION.MOVE_DOWN:\n      shape = moveShape(gameState.shape, [0, 1]);\n      break;\n    case ACTION.MOVE_LEFT:\n      shape = moveShape(gameState.shape, [-1, 0]);\n      break;\n    case ACTION.MOVE_RIGHT:\n      shape = moveShape(gameState.shape, [1, 0]);\n      break;\n    case ACTION.ROTATE:\n      shape = rotateShape(gameState.shape);\n      break;\n    default:\n      shape = moveShape(gameState.shape, [0, 1]);\n      break;\n  }\n\n  if (hasCollision(shape, gameState.unclearedGrid)) {\n    if (action === ACTION.MOVE_DOWN) {\n      // 👍: method composition\n      unclearedGrid = flow(\n        curry(addShapeToGrid)(gameState.shape),\n        clearFullRows\n      )(gameState.unclearedGrid);\n\n      // check if game over\n      if (shape.position[1] < 0) {\n        // TODO: I am not happy with isGame being reassigned\n        isGameOver = true;\n        shape = cloneDeep(gameState.shape);\n      } else {\n        shape = getNextShape(unclearedGrid.cols);\n      }\n    } else {\n      // just cannot move the shape, so game state keeps unchanged\n      return cloneDeep(gameState);\n    }\n  } else {\n    unclearedGrid = cloneDeep(gameState.unclearedGrid);\n  }\n\n  // calculate the grid for display by combining the shape and uncleared grid\n  const displayGrid = addShapeToGrid(shape, unclearedGrid);\n\n  return {\n    shape,\n    unclearedGrid,\n    displayGrid,\n    isGameOver\n  };\n};\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport Grid from \"./components/Grid/Grid\";\n\nimport { ACTION, createGameState, getNextGameState } from \"./types/GameState\";\n\nclass Tetris extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {};\n  }\n\n  componentDidMount() {\n    // register events\n    document.addEventListener(\"keydown\", this.handleKeyDown);\n\n    this.startNewGame();\n  }\n\n  componentWillUnmount() {\n    // deregister events\n    document.removeEventListener(\"keydown\", this.handleKeyDown);\n  }\n\n  handleKeyDown = e => {\n    switch (e.keyCode) {\n      case 32: // SPACE\n      case 38: // UP\n        this.rotateShape();\n        break;\n      case 37: // LEFT\n        this.moveShapeLeft();\n        break;\n      case 39: // RIGHT\n        this.moveShapeRight();\n        break;\n      case 40: // DOWN\n        this.moveShapeDown();\n        break;\n      default:\n        break;\n    }\n  };\n\n  startNewGame = () => {\n    const { rows, cols, tickInterval } = this.props;\n\n    this.gameState = createGameState(rows, cols);\n    this.setState(this.gameState);\n\n    this.timer = setTimeout(this.doGameTick, tickInterval);\n  };\n\n  doGameTick = () => {\n    if (!this.gameState.isGameOver) {\n      const { tickInterval } = this.props;\n\n      this.moveShapeDown();\n\n      // do next tick\n      this.timer = setTimeout(this.doGameTick, tickInterval);\n    } else {\n      alert(\"Game Over!\");\n\n      this.startNewGame();\n    }\n  };\n\n  // impure function\n  moveShapeDown = () => {\n    this.gameState = getNextGameState(ACTION.MOVE_DOWN, this.gameState);\n\n    this.setState(this.gameState);\n  };\n\n  // impure function\n  moveShapeLeft = () => {\n    this.gameState = getNextGameState(ACTION.MOVE_LEFT, this.gameState);\n\n    this.setState(this.gameState);\n  };\n\n  // impure function\n  moveShapeRight = () => {\n    this.gameState = getNextGameState(ACTION.MOVE_RIGHT, this.gameState);\n\n    this.setState(this.gameState);\n  };\n\n  // impure function\n  rotateShape = () => {\n    this.gameState = getNextGameState(ACTION.ROTATE, this.gameState);\n\n    this.setState(this.gameState);\n  };\n\n  render() {\n    const { displayGrid } = this.state;\n\n    return <div>{displayGrid && <Grid grid={displayGrid} />}</div>;\n  }\n}\n\nTetris.propTypes = {\n  rows: PropTypes.number.isRequired,\n  cols: PropTypes.number.isRequired,\n  tickInterval: PropTypes.number.isRequired\n};\n\nTetris.defaultProps = {\n  rows: 20,\n  cols: 10,\n  tickInterval: 400\n};\n\nexport default Tetris;\n","import React from \"react\";\nimport Tetris from \"./Tetris/Tetris\";\nimport tetrisBg from \"./tetris-bg.mp3\";\nimport \"./App.css\";\n\nfunction App() {\n  return (\n    <div className=\"app\">\n      <p>\n        Tetris using <strong>Functional Programming</strong> approach\n      </p>\n      <Tetris rows={20} cols={10} normalInterval={400} />\n      <audio src={tetrisBg} type=\"audio/mpeg\" autoPlay={true} loop={true} />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/tetris-bg.4ae866dc.mp3\";"],"sourceRoot":""}